package io.shiftleft.codepropertygraph.generated.v2
import io.joern.odb2
import io.shiftleft.codepropertygraph.generated.v2.nodes
import io.shiftleft.codepropertygraph.generated.v2.edges

object GraphSchema extends odb2.Schema {
  val nodeLabels = Array("ANNOTATION", "ANNOTATION_LITERAL", "ANNOTATION_PARAMETER", "ANNOTATION_PARAMETER_ASSIGN", "ARRAY_INITIALIZER", "BINDING", "BLOCK", "CALL", "CLOSURE_BINDING", "COMMENT", "CONFIG_FILE", "CONTROL_STRUCTURE", "DEPENDENCY", "FIELD_IDENTIFIER", "FILE", "FINDING", "IDENTIFIER", "IMPORT", "JUMP_LABEL", "JUMP_TARGET", "KEY_VALUE_PAIR", "LITERAL", "LOCAL", "LOCATION", "MEMBER", "META_DATA", "METHOD", "METHOD_PARAMETER_IN", "METHOD_PARAMETER_OUT", "METHOD_REF", "METHOD_RETURN", "MODIFIER", "NAMESPACE", "NAMESPACE_BLOCK", "RETURN", "TAG", "TAG_NODE_PAIR", "TEMPLATE_DOM", "TYPE", "TYPE_ARGUMENT", "TYPE_DECL", "TYPE_PARAMETER", "TYPE_REF", "UNKNOWN")
  val nodeIdByLabel = nodeLabels.zipWithIndex.toMap
  val edgeLabels = Array("ALIAS_OF",  "ARGUMENT",  "AST",  "BINDS",  "BINDS_TO",  "CALL",  "CAPTURE",  "CAPTURED_BY",  "CDG",  "CFG",  "CONDITION",  "CONTAINS",  "DOMINATE",  "EVAL_TYPE",  "IMPORTS",  "INHERITS_FROM",  "IS_CALL_FOR_IMPORT",  "PARAMETER_LINK",  "POST_DOMINATE",  "REACHING_DEF",  "RECEIVER",  "REF",  "SOURCE_FILE",  "TAGGED_BY")
  val edgeIdByLabel = edgeLabels.zipWithIndex.toMap
  val edgePropertyAllocators: Array[Int => Array[_]] = Array(size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => null, size => Array.fill(size)("<empty>") /*label = REACHING_DEF, id = 19*/, size => null, size => null, size => null, size => null)
  val nodeFactories: Array[(odb2.Graph, Int) => nodes.StoredNode] = Array((g, seq) => new nodes.Annotation(g, seq), (g, seq) => new nodes.AnnotationLiteral(g, seq), (g, seq) => new nodes.AnnotationParameter(g, seq), (g, seq) => new nodes.AnnotationParameterAssign(g, seq), (g, seq) => new nodes.ArrayInitializer(g, seq), (g, seq) => new nodes.Binding(g, seq), (g, seq) => new nodes.Block(g, seq), (g, seq) => new nodes.Call(g, seq), (g, seq) => new nodes.ClosureBinding(g, seq), (g, seq) => new nodes.Comment(g, seq), (g, seq) => new nodes.ConfigFile(g, seq), (g, seq) => new nodes.ControlStructure(g, seq), (g, seq) => new nodes.Dependency(g, seq), (g, seq) => new nodes.FieldIdentifier(g, seq), (g, seq) => new nodes.File(g, seq), (g, seq) => new nodes.Finding(g, seq), (g, seq) => new nodes.Identifier(g, seq), (g, seq) => new nodes.Import(g, seq), (g, seq) => new nodes.JumpLabel(g, seq), (g, seq) => new nodes.JumpTarget(g, seq), (g, seq) => new nodes.KeyValuePair(g, seq), (g, seq) => new nodes.Literal(g, seq), (g, seq) => new nodes.Local(g, seq), (g, seq) => new nodes.Location(g, seq), (g, seq) => new nodes.Member(g, seq), (g, seq) => new nodes.MetaData(g, seq), (g, seq) => new nodes.Method(g, seq), (g, seq) => new nodes.MethodParameterIn(g, seq), (g, seq) => new nodes.MethodParameterOut(g, seq), (g, seq) => new nodes.MethodRef(g, seq), (g, seq) => new nodes.MethodReturn(g, seq), (g, seq) => new nodes.Modifier(g, seq), (g, seq) => new nodes.Namespace(g, seq), (g, seq) => new nodes.NamespaceBlock(g, seq), (g, seq) => new nodes.Return(g, seq), (g, seq) => new nodes.Tag(g, seq), (g, seq) => new nodes.TagNodePair(g, seq), (g, seq) => new nodes.TemplateDom(g, seq), (g, seq) => new nodes.Type(g, seq), (g, seq) => new nodes.TypeArgument(g, seq), (g, seq) => new nodes.TypeDecl(g, seq), (g, seq) => new nodes.TypeParameter(g, seq), (g, seq) => new nodes.TypeRef(g, seq), (g, seq) => new nodes.Unknown(g, seq))
  val edgeFactories: Array[(odb2.GNode, odb2.GNode, Int, Any) => odb2.Edge] = Array((s, d, subseq, p) => new edges.AliasOf(s, d, subseq, p), (s, d, subseq, p) => new edges.Argument(s, d, subseq, p), (s, d, subseq, p) => new edges.Ast(s, d, subseq, p), (s, d, subseq, p) => new edges.Binds(s, d, subseq, p), (s, d, subseq, p) => new edges.BindsTo(s, d, subseq, p), (s, d, subseq, p) => new edges.Call(s, d, subseq, p), (s, d, subseq, p) => new edges.Capture(s, d, subseq, p), (s, d, subseq, p) => new edges.CapturedBy(s, d, subseq, p), (s, d, subseq, p) => new edges.Cdg(s, d, subseq, p), (s, d, subseq, p) => new edges.Cfg(s, d, subseq, p), (s, d, subseq, p) => new edges.Condition(s, d, subseq, p), (s, d, subseq, p) => new edges.Contains(s, d, subseq, p), (s, d, subseq, p) => new edges.Dominate(s, d, subseq, p), (s, d, subseq, p) => new edges.EvalType(s, d, subseq, p), (s, d, subseq, p) => new edges.Imports(s, d, subseq, p), (s, d, subseq, p) => new edges.InheritsFrom(s, d, subseq, p), (s, d, subseq, p) => new edges.IsCallForImport(s, d, subseq, p), (s, d, subseq, p) => new edges.ParameterLink(s, d, subseq, p), (s, d, subseq, p) => new edges.PostDominate(s, d, subseq, p), (s, d, subseq, p) => new edges.ReachingDef(s, d, subseq, p), (s, d, subseq, p) => new edges.Receiver(s, d, subseq, p), (s, d, subseq, p) => new edges.Ref(s, d, subseq, p), (s, d, subseq, p) => new edges.SourceFile(s, d, subseq, p), (s, d, subseq, p) => new edges.TaggedBy(s, d, subseq, p))
  val nodePropertyAllocators: Array[Int => Array[_]] = Array(size => new Array[String](size), size => new Array[Int](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[Int](size), size => new Array[Int](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[Boolean](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[Int](size), size => new Array[String](size), size => new Array[Boolean](size), size => new Array[Boolean](size), size => new Array[Boolean](size), size => new Array[Boolean](size), size => new Array[String](size), size => new Array[String](size), size => new Array[Int](size), size => new Array[Int](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[Int](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[String](size), size => new Array[odb2.GNode](size), size => new Array[odb2.GNode](size))
  val normalNodePropertyNames = Array("ALIAS_TYPE_FULL_NAME", "ARGUMENT_INDEX", "ARGUMENT_NAME", "AST_PARENT_FULL_NAME", "AST_PARENT_TYPE", "CANONICAL_NAME", "CLASS_NAME", "CLASS_SHORT_NAME", "CLOSURE_BINDING_ID", "CLOSURE_ORIGINAL_NAME", "CODE", "COLUMN_NUMBER", "COLUMN_NUMBER_END", "CONTAINED_REF", "CONTENT", "CONTROL_STRUCTURE_TYPE", "DEPENDENCY_GROUP_ID", "DISPATCH_TYPE", "DYNAMIC_TYPE_HINT_FULL_NAME", "EVALUATION_STRATEGY", "EXPLICIT_AS", "FILENAME", "FULL_NAME", "HASH", "IMPORTED_AS", "IMPORTED_ENTITY", "INDEX", "INHERITS_FROM_TYPE_FULL_NAME", "IS_EXPLICIT", "IS_EXTERNAL", "IS_VARIADIC", "IS_WILDCARD", "KEY", "LANGUAGE", "LINE_NUMBER", "LINE_NUMBER_END", "METHOD_FULL_NAME", "METHOD_SHORT_NAME", "MODIFIER_TYPE", "NAME", "NODE_LABEL", "ORDER", "OVERLAYS", "PACKAGE_NAME", "PARSER_TYPE_NAME", "POSSIBLE_TYPES", "ROOT", "SIGNATURE", "SYMBOL", "TYPE_DECL_FULL_NAME", "TYPE_FULL_NAME", "VALUE", "VERSION")
  val nodePropertyByLabel = normalNodePropertyNames.zipWithIndex.toMap.updated("evidence", 53).updated("node", 53).updated("keyValuePairs", 54).updated("tag", 54)

 override def getNumberOfNodeKinds: Int = 44
 override def getNumberOfEdgeKinds: Int = 24
 override def getNodeLabel(nodeKind: Int): String = nodeLabels(nodeKind)
 override def getNodeIdByLabel(label: String): Int = nodeIdByLabel.getOrElse(label, -1)
 override def getEdgeLabel(nodeKind: Int, edgeKind: Int): String = edgeLabels(edgeKind)
 override def getEdgeIdByLabel(label: String): Int = edgeIdByLabel.getOrElse(label, -1)
 override def getPropertyLabel(nodeKind: Int, propertyKind: Int): String =
    if(propertyKind < 53) normalNodePropertyNames(propertyKind)
    else if(propertyKind == 53 && nodeKind == 15) "evidence" /*on node FINDING*/
    else if(propertyKind == 53 && nodeKind == 23) "node" /*on node LOCATION*/
    else if(propertyKind == 53 && nodeKind == 36) "node" /*on node TAG_NODE_PAIR*/
    else if(propertyKind == 54 && nodeKind == 15) "keyValuePairs" /*on node FINDING*/
    else if(propertyKind == 54 && nodeKind == 36) "tag" /*on node TAG_NODE_PAIR*/
    else null
 
 override def getPropertyIdByLabel(label: String): Int = nodePropertyByLabel.getOrElse(label, -1)
 override def getNumberOfProperties: Int = 55
 override def makeNode(graph: odb2.Graph, nodeKind: Short, seq: Int): nodes.StoredNode = nodeFactories(nodeKind)(graph, seq)
 override def makeEdge(src: odb2.GNode, dst: odb2.GNode, edgeKind: Short, subSeq: Int, property: Any): odb2.Edge = edgeFactories(edgeKind)(src, dst, subSeq, property)
 override def allocateEdgeProperty(nodeKind: Int, direction: odb2.Edge.Direction, edgeKind: Int, size: Int): Array[_] = edgePropertyAllocators(edgeKind)(size)
 override def allocateNodeProperty(nodeKind: Int, propertyKind: Int, size: Int): Array[_] = nodePropertyAllocators(propertyKind)(size)
}